---
sidebar_position: 1
---

# Your first web scenario

```mdx-code-block
import Figure from '@site/src/components/Figure'
```

Key points:
- Serenity/JS works well with popular development environments, including the free [Visual Studio Code](https://code.visualstudio.com/).
- Serenity/JS tests are just high-quality code, so all your regular programming tools will work as expected.
- Serenity/JS `describe` function declares a group of test scenarios, `it` function declares a single test scenario
- Serenity/JS has first-class support for the asynchronous nature of JavaScript and takes advantage of modern language features.

In this section, you'll learn the basics of web testing with Serenity/JS; I'll show you how to **run and debug existing tests**,
and **how to write new test scenarios**. While we'll focus on helping you **get the basics right**, I'll point you to the more **advanced
techniques** and **patterns** when needed.

We'll be using a [**Gitpod.io workspace**](/handbook/getting-started#serenityjs-gitpods) to work with Serenity/JS in your web browser, so there's **no need to install anything** on you computer.
If you prefer to set up Serenity/JS locally instead, follow the installation instructions in [Serenity/JS + Playwright Test project template](https://github.com/serenity-js/serenity-js-playwright-test-template).

:::info Pro Tip
If you get lost or stumble upon a problem you're not quite sure how to solve - **[Serenity/JS Community Chat](https://gitter.im/serenity-js/Lobby)** is here to help.
:::

## Launching your workspace

All [Serenity/JS project templates](/handbook/getting-started#serenityjs-project-templates), such as the one we'll be using in this chapter,
[support Gitpod.io workspaces](/handbook/getting-started#serenityjs-gitpods) and are configured to
make it easy for you to use them in a Visual Studio Code-based development environment.
Of course, since Serenity/JS tests are standards-based Node.js code, they'll work just as well in any other modern <abbr title="Integrated Development Environment">IDE</abbr>.

In this tutorial, we'll be using [Serenity/JS + Playwright Test template](https://github.com/serenity-js/serenity-js-playwright-test-template),
which integrates Serenity/JS with [Playwright](https://playwright.dev/) web testing library and its dedicated [Playwright Test](https://playwright.dev/docs/test-runners#playwright-test) test runner.
The test suite we'll be working on interacts with a simple to-do list app that you can experiment with at [todo-app.serenity-js.org](https://todo-app.serenity-js.org/).

To launch your workspace, make sure you have a [GitHub account](/handbook/getting-started#your-githubcom-account), which will make it easier for you to use other [Serenity/JS resources](/handbook/getting-started) too.
Next, launch your Gitpod.io web IDE using the "Open in Gitpod" button below and sign in to your Gitpod.io workspace using your GitHub account.

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/serenity-js/serenity-js-playwright-test-template)

:::info Did you know?
Serenity/JS integrates with several popular test runners, such as Cucumber, Mocha, Jasmine and Playwright Test, as well as various web integration tools,
such as Selenium, Playwright and WebdriverIO. Once you know your way around your first [Serenity/JS project template](https://github.com/serenity-js/?q=template&type=all&language=&sort=),
picking the one that's right for your team and your project will become a breeze.
:::

## Running tests in Visual Studio Code

[Serenity/JS + Playwright Test template](https://github.com/serenity-js/serenity-js-playwright-test-template)
you've just opened in your Gitpod workspace includes several example test scenarios
located under the [`spec` directory](https://github.com/serenity-js/serenity-js-playwright-test-template/tree/main/spec).

You can view them using your [Visual Studio Code Project Explorer sidebar](https://code.visualstudio.com/docs/getstarted/userinterface), which should show a directory structure similar to this:

<Figure
    caption='Visual Studio Code user interface showing an example test scenario'
    img={require('@site/static/images/web-testing/your-first-web-scenario/vscode-ui.png')}
/>

There are two ways to run Playwright tests in Visual Studio Code, and you can do it either by:
- using the play/check mark icon next to the name of the test in a `.spec.ts` file,
- using the play icon in the Visual Studio Code Test Explorer panel, which shows all the test scenarios Visual Studio Code has detected in your project, as per the screenshot below:

<Figure
    caption='Visual Studio Code Test Explorer panel showing test scenarios detected in the project'
    img={require('@site/static/images/web-testing/your-first-web-scenario/vscode-testing-panel.png')}
/>

Once you've inspected the [`spec/recording-items.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/recording-items.spec.ts),
you will notice that we're using two functions provided by the [`@serenity-js/playwright-test`](/api/playwright-test) module that help to organise a test suite:
- [`it`](/api/playwright-test/function/it) - to declare a single test scenario
- [`describe`](/api/playwright-test/function/describe) - to declare a group of test scenarios

Those [`describe`](/api/playwright-test/function/describe) and [`it`](/api/playwright-test/function/it) functions are wrappers around
Playwright Test [`test.describe`](https://playwright.dev/docs/api/class-test#test-describe-1) and [`test`](https://playwright.dev/docs/api/class-test#test-call) functions, respectively.

In addition to the functionality offered by Playwright [`test`](https://playwright.dev/docs/api/class-test#test-call) function, Serenity/JS [`it`](/api/playwright-test/function/it) wrapper offers [Serenity/JS-specific
test fixtures](/api/playwright-test/interface/SerenityFixtures), such as [`actor`](/api/playwright-test/interface/SerenityFixtures#actor), [`actorCalled`](/api/playwright-test/interface/SerenityFixtures#actorCalled),
or [`crew`](/api/playwright-test/interface/SerenityFixtures#crew). I'll tell you about them in a moment, but first, let's run the scenarios.


:::info Pro Tip

If Visual Studio Code didn't detect any test scenarios in your project, or if it doesn't display the play/check mark icon next to the name of the test,
use the "Refresh Tests" icon in the Test Explorer to reload test configuration.

<Figure
    caption='Visual Studio Code UI showing the "Refresh tests" button'
    img={require('@site/static/images/web-testing/your-first-web-scenario/vscode-refresh-tests.png')}
/>

:::

### Exercises

To get familiar with running Serenity/JS test scenarios in Visual Studio Code, conduct the following experiments:
1. Open [`spec/recording-items.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/recording-items.spec.ts) and run test scenarios such as`it('should clear text input field when an item is added')` individually using the play/check mark icon next to the `it` block. Make sure they're passing.
1. Run a group of test scenarios by clicking on the play/check mark icon next to the `describe` block, such as `describe('Todo List App')`. Make sure they're passing.
1. Run individual test scenarios using Visual Studio Code Test Explorer panel.
1. Navigate from a test scenario in a Visual Studio Code Test Explorer panel to its location in the codebase using the "Go to test" icon next to the name of the test.

## Writing Serenity/JS test scenarios

Now that you know how to run Serenity/JS test scenarios in VS Code, let's talk about what's involved in writing some new ones.

First, add the bellow code snippet to your existing test suite in [`spec/recording-items.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/recording-items.spec.ts)
by placing it inside the `describe('Todo List App')` block.
Make sure that you can run this new scenario and that it's passing, and we'll analyse its structure line by line in just a moment.

```typescript
it('should allow me to add a todo item', async ({ actor }) => {
    await actor.attemptsTo(
        startWithAnEmptyList(),

        recordItem('Buy some milk'),

        Ensure.that(itemNames(), equals([
            'Buy some milk',
        ])),
    );
});
```

Well done, you've just created your first Serenity/JS test scenario!

As you can see above, well-written Serenity/JS test scenarios are **concise**, **easy to read**, and **easy to understand**
even to audiences who might not necessarily have background in technology.
That's because Serenity/JS is designed to help you express your scenarios in the **domain language of your company** and **your business**
and avoid incidental detail and low-level implementation noise that could cloud the picture.

### Designing actor-centred test scenarios

You might have noticed that the scenario you've just added starts with an `actor`.
In fact, all Serenity/JS test scenarios are **actor-centred** and start like that.
This design based on the  [**Screenplay Pattern**](/handbook/design/screenplay-pattern) helps your test scenarios
shift away from automation and integration tools taking centre stage
and instead focus on [**actors**](/api/core/class/Actor), so **people** and **processes** interacting with
the **system under test**.

So what are _actors_? Actors can represent **end-users**, like a shopper interacting with an online store,
or a traveller interacting with a flight booking system. However, actors can also represent **automated processes** and **external systems**
_acting upon_ the system under test.
Examples here could include an external financial data provider submitting asset price information to our batch processing system,
or a website crawler bot scanning a web UI and receiving a different version than a regular user. You can also use actors to represents
**components** of a software system initiating some interaction with the component we're interested in, like a microservice sending requests to another microservice under test.

From the implementation perspective, [Serenity/JS Playwright Test](/api/playwright-test)
module takes care of initialising and injecting actors into your test scenarios
and dismissing them and freeing their resources when the test scenario is finished.

All you need to do is to import the [`it`](/api/playwright-test/function/it) function and tell it to give you an `actor`, like this:

```typescript
import { it } from '@serenity-js/playwright-test'; // Serenity/JS `it` wrapper

// ...

it('should allow me to add a todo item', async ({ actor }) => { // injected `actor`
    await actor.attemptsTo(
        // ...
    )
});
```

Serenity/JS test scenarios can involve **one or multiple actors**. This is useful, for example, when designing scenarios for contexts
where several actors interact with one another, or where several actors are required to complete different parts of a larger workflow.
Examples of such contexts include multi-user workflow systems, messaging systems, video games, and so on.
You can see an example of a basic multi-actor test scenario in [`spec/multi-actor.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/multi-actor.spec.ts).

### Modelling a workflow using reusable activities

The role of Serenity/JS actors is to interact with the system under test by performing [**activities**](/api/core/class/Activity).

You use activities to model the logical elements of a workflow that an end-user or an external system interacting with the system under test
would perform to accomplish some **goal**.

From the implementation perspective, **Serenity/JS activities** are the **most basic form of code reuse** and manifest themselves
as either [_tasks_](/api/core/class/Task) or [_interactions_](/api/core/class/Interaction).
We'll discuss both of those in detail when we talk about the [Screenplay Pattern](/handbook/design/screenplay-pattern),
but for now let's use the following definitions:
- **interactions** are low-level activities that **interact directly** with an interface of the system under test to [click](/api/web/class/Click) on a button in a web UI or to [send](/api/rest/class/Send) a `POST` request to a REST API - Serenity/JS provides [dozens of them](/api/web) out of the box,
- **tasks** are **composites of other activities**, created to give **business domain meaning** to sequences of activities, such as task to "record a to-do item", or a task to "create a customer account".

In our example, a **task** that accomplishes a **goal** to "record a to-do item" can be achieved by performing three lower-level activities:
- enter the name of the to-do item into a "What needs to be done?" input box,
- press the enter key,
- make sure the item is recorded as expected.

You can try to perform them manually yourself at [todo-app.serenity-js.org](https://todo-app.serenity-js.org/):

<Figure
    caption='Demonstration of recording a to-do item'
    img={require('@site/static/images/web-testing/your-first-web-scenario/todo-app-record-an-item.gif')}
/>

To see how a task like that would be implemented with Serenity/JS,
open [`spec/todo-list-app/TodoApp/tasks.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/todo-list-app/TodoApp/tasks.ts#7)
and review the implementation of a task to `recordItem`:

```typescript
import { contain } from '@serenity-js/assertions';
import { Task, Wait } from '@serenity-js/core';
import { Enter, Key, Press } from '@serenity-js/web';

export const recordItem = (name: string): Task =>           // 1 - reusable function
    Task.where(`#actor records an item called ${ name }`,   // 2 - task description
        Enter.theValue(name).into(newTodoInput()),          // 3 - lower-level activities
        Press.the(Key.Enter).in(newTodoInput()),
        Wait.until(itemNames(), contain(name)),
    )
```

In the listing above, you can see that a definition of a Serenity/JS task is **compact**, **easy to understand**,
and reads almost exactly like the **human-readable** description I showed you a moment ago.

To implement custom tasks like this and capture the language of _your_ business domain all you need is just a few lines of code where you define:
1. **reusable function**, named after the goal an actor will accomplish having performed a given task, e.g. `recordItem`,
2. **task description**, used for [test reporting](/handbook/reporting/) purposes,
3. **sequence of lower-level activities** that constitute a task.

What's important to reiterate here is that Serenity/JS activities are **reusable**.
This means you could write a task like the one to `recordItem` just once
and reuse it in any scenario that needs to record to-do items.
If the steps involved in _how_ an actor would go about recording a to-do item in your system were to change,
you'd only have to update them in this **one place in your codebase** where the task is defined,
and not in every single scenario that uses it.

:::info Did you know?
Task decomposition model implemented by Serenity/JS is based on Hierarchical Task Analysis, a technique typically used in User-Centred Design.
You can read more about it in my article ["User-Centred Design: How a 50-year-old technique became the key to scalable test automation"](https://janmolak.com/user-centred-design-how-a-50-year-old-technique-became-the-key-to-scalable-test-automation-66a658a36555)
:::

You can define as many or as few tasks as it makes sense to reflect the workflows in your domain.
You can make your tasks as high-level or as low-level as you wish.
You're not limited to interacting with just the web interfaces either!
In fact, you can make your Serenity/JS actors interact with **any interface of your system under test**,
be it **web UIs**, **REST APIs**, **mobile apps**, or whatever a Node.js program can talk to.

To make your work easier, Serenity/JS modules provide [**dozens of lower-level interactions**](/api/core) you can compose your custom tasks from.
This will help you focus on **modelling your business workflows** and **designing your test scenarios** instead of wasting time
having to figure out how to integrate with the given interface, or trying to integrate several incompatible libraries together.

Serenity/JS activity-based code reuse model also means that as you evolve the vocabulary of your domain-specific tasks
over time, writing test scenarios becomes easier as you're simply re-arranging existing tasks into new scenarios.

### Exercises

1.  Compare a single-actor scenario in [`spec/recording.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/recording-items.spec.ts)
    and a multi-actor scenario in [`spec/multi-actor.spec.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/multi-actor.spec.ts).
    What differences and what similarities can you see in how the actors are accessed?
1.  Inspect tasks in [`spec/todo-list-app/TodoItem/tasks.ts`](https://github.com/serenity-js/serenity-js-playwright-test-template/blob/main/spec/todo-list-app/TodoItem/tasks.ts).
    What Serenity/JS web interactions do they use? Can you find their usage examples in the API docs of the [`@serenity-js/web`](/api/web) module?
1.  Write another test that adds two items to the to-do list and verifies they've been added correctly. What task can you reuse?
1.  Add another interaction to your new test - an assertion that verifies the number of items in the list: `Ensure.that(itemNames().length, equals(2))`
1.  See if you can create a test that adds 2 items, removes one of them, and then verifies the items that are left. Reuse the existing task to `remove(itemName)`.
1.  Compare the activity-based code reuse model used by Serenity/JS with other code reuse models you've seen used in the context of test automation in the past.
    How do they compare?

## Identifying page elements

## Analysing test failures

You should never trust a test you've never seen fail, so the next thing we're going to look at is how to analyse test failures.

## Debugging tests

Add a debug statement
open VNC
run in debug mode

## Running tests on CI

## Viewing reports

## Configuring test runner

[Configure Playwright Test](/handbook/test-runners/playwright-test)
